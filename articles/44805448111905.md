---
title: "Nand2tetrisをGoで実装する ~ アセンブラ編 ~"
emoji: "😺"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Go","nand2tetris","assembly"]
published: false
---

# Nand2tetrisを実装する・目次 
1. [Nand2tetrisを実装する  ~ ハードウェア編(1 ~ 5章) ~](https://zenn.dev/yukiyada/articles/1c5708ddfb36db)
2. **Nand2tetrisをGoで実装する ~ アセンブラ編(6章) ~**
3. Nand2tetrisをGoで実装する ~ 中間言語・Virtual Machine編(7,8章) ~ (執筆中)
4. Nand2tetrisをGoで実装する ~ コンパイラ編(10,11章) ~ (執筆中)

# 1.はじめに

**「コンピュータの中では何が起こっているのか？」**
 
近年、ソフトウェア開発を取り巻く技術は急速に発展し、ほとんどの人にとって、コンピュータの内部構造はブラックボックス化しているのではないでしょうか。かくいう私もその一人。コンピュータの内部構造を知らずとも、「技術の使い方」さえ知っていれば、プロダクションレベルのアプリケーションが実装できてしまう時代です。

しかし、仮にもソフトウェアエンジニアを名乗るのであれば、基本的な構造くらいは理解しておきたいもの。そう思った私は、低レイヤーの勉強のために、書籍「コンピュータシステムの理論と実装」が提供するNand2tetrisというプロジェクトに取り組みました。以下は実装したリポジトリです。

https://github.com/YadaYuki/nand2tetris-golang

そして、本記事は「コンピュータシステムの理論と実装」の6章に該当するアセンブラ編の実装に関する記事です。

# 2.コンピュータシステムの理論と実装(Nand2tetris)

本章では「コンピュータシステムの理論と実装」という書籍、またその書籍が提供するプロジェクトであるNand2tetrisについて簡単に説明していきます。

https://www.oreilly.co.jp/books/9784873117126/

本書の目的はコンピュータシステムを実際に作り、その作業を通して、コンピュータシステムを深く理解すること。Nand2tetrisというプロジェクト名はNANDゲートを最小素子として、機械語が動作するようなハードウェアを構築し、アセンブラやコンパイラを実装し、最終的にはテトリスが動作するようなコンピュータを構築するという特徴から名付けられています。

そして、本記事・アセンブラ編では、Nand2tetrisが提供する**Hackアセンブリというオリジナルのアセンブリ言語を、前の記事・ハードウェア編で実装したCPU([CPU.hdl](https://github.com/YadaYuki/nand2tetris-golang/blob/main/hardware/computer/CPU.hdl))上で動作するような機械語に変換するアセンブラをGo言語で実装します**。


# 3.アセンブリとは？

前の記事(ハードウェア編)では、16bit機械語が動作するようなコンピュータ・CPUを作成しました。ここで、CPU上で実行することができる16bit機械語によるプログラムを見てみましょう。

```
0000000000000010
1110110000010000
0000000000000011
1110000010010000
0000000000000000
1110001100001000
```
上の機械語プログラムは「2+3の計算結果をデータメモリの0番地に格納する」という単純な処理を実行するプログラムなのですが、**一目見ただけではそのことが全くわからないかと思います。**(少なくとも、私にはわかりませんでした)

このように機械語というのは直感的には理解しづらく、それを直接記述して、プログラムを組んでいく、というのは人間的な作業とは言い難い上に、効率が悪いです。**そこで開発されたのがアセンブリ言語(アセンブリ)です。**

アセンブリは機械語に対応する命令を"Add R2,R1,R3"のような記号の組み合わせで表現します。そして、**アセンブリによるプログラムを機械語に変換するソフトウェアのことをアセンブラ**と呼びます。

## 4.Hackアセンブリの文法

文法に関して、事細かに説明していく前に、前章で提示した「2+3の計算結果をデータメモリの0番地に格納する」プログラムのHackアセンブラバージョンを例としてみてみましょう。

```
@2  // Aレジスタに2を格納
D=A // DレジスタにA(=2) を格納
@3
D=D+A  // D レジスタにD+A(=2 + 3)の計算結果を格納
@0 
M=D // RAM[0]にdレジスタの値を格納
```

多くの人にとって、機械語で書かれたプログラムよりも、幾分、実行される処理の内容が読み解きやすくなっているのではないでしょうか？

Hackアセンブリでは、各行に記述された命令・ラベルである「コマンド」を最小単位として、それらを組み合わせていくことによってプログラムを構築していきます。ここで、Hackアセンブリには

- A命令(Aコマンド)
- C命令(Cコマンド)
- ラベル(Lコマンド)

という3つの文法が存在します。

- **Aコマンド**

Aコマンドは`@{定数 or 変数名}`という文法で表されるコマンドです。このコマンドを実行することによって、Aレジスタ内に任意の値を格納することができます。

さて、Aレジスタに格納された値はどんな用途に用いられるのでしょうか？大きく分けて

- 演算処理で用いられる定数の格納
- データメモリの特定のアドレスへのアクセス
- Jump命令のジャンプ先の格納

という3つが挙げられます。

たとえば、先ほど示した「2+3の計算結果をデータメモリの0番地に格納する」プログラムの中ではこのうち

- **Cコマンド**

Cコマンドでは、加算や減算、条件分岐といった「演算処理」を記述するHackアセンブリの中心的コマンドです。Cコマンドの文法を一般化すると、以下のような構造をしています。

```
dest=comp;jump
```

Cコマンドを構成する要素の各役割は以下の通りです。

- dest:compの代入先となるレジスタ(ex:D,M) 
- comp:計算式(ex:D+1)やレジスタ名
- jump:jump命令であった時、その命令(ex:JGT)

先ほどのプログラムの中に登場するCコマンド`D=D+A`をCコマンドを構成する要素に分解してみると

- dest:`D`
- comp:`D+A`
- jump:なし

となります。

- **Lコマンド**

最後にLコマンドです。LコマンドはJump命令がJumpする先であるラベルの役割を果たします。

```
(ADD_FUNCTION) // Lコマンド
...
...
...
@ADD_FUNCTION
0;JMP // Aレジスタに格納されているアドレス(＝ADD_FUNCTIONラベルが貼られているアドレス)にジャンプ
...
```

以上がHackアセンブリの文法に関する説明です。それでは次章以降では、いよいよそれらを機械語に変換するアセンブラを実装していきます。


# 5.HackアセンブラのGoによる実装

## 5.1 アセンブリが機械語に変換されるまで

詳細な実装についてみていく前にまずは全体像です。今回、私が実装したGoによるHackアセンブラが「アセンブリを機械語に変換する」プロセスを図示すると以下の通りになります。

![image](https://user-images.githubusercontent.com/57289763/143969126-c2fe4a43-b598-4563-9c5f-b04a853f513e.png)

アセンブリを機械語に変換するまでのプロセスは**アセンブリ言語によるプログラムを、3種類あるコマンドのそれぞれの文法をモデル化したastノードの配列に変換する**「**構文解析**」と **構文解析により得られたastノードの配列の各要素を機械語に変換する**「**機械語への変換**」という大きく2つのステップに分けることが可能です。それでは詳細な実装を見ていきましょう。

## 5.2 assemblerパッケージのフォルダ構成
  
## 5.3 抽象構文木の定義(ast.go)
  
## 5.4 構文解析(parser.go)
  
## 5.5 機械語への変換・構文木評価(code.go)
  
## 5.6 Add.asmを機械語に変換する.

# 6.最後に

